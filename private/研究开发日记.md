+ **八月二十九日**
  设计一个计算h值的函数，f = g(与采用的指标有关)+h（被重复看过的点的个数）-》需要乘以一定的比例 
  以min-max指标为例：
  被重复看过的点需要进行分类，试图分配给簇的大小未达到平衡尺寸的簇：

1. 初始path，计算每个簇都看见的点，并集，然后求出被重复看的点 -》完成
2. 考虑对重复看的点进行重新分配，前提是这个点是在大簇的路径上的，否则分配无意义 -》完成
3. 将重复的点分配之后，需要截断路径，abcdb,拿走b的话，就要截断bcd（第一次出现该点和第二次出现该点之间的距离，如果没第二次，那就拿走之后的全部) -》完成
4. 拿走路径上的点之后，大簇的cell集合-路径上剩下的点能看到的范围能找到孤立点，将孤立点也划分给小簇

存在问题：

path length : 14 29 28

![image-20220829144058875](C:\Users\18959\AppData\Roaming\Typora\typora-user-images\image-20220829144058875.png)

这种情况下，并没有某个路径上的cell被重复观察，无法再分配，但是显然应该增加红色的长度减短蓝绿

->应该按照平衡聚类的思想来处理

单纯取被重复观察的点是不够的，要找到边境上能直接改变路径长度的点

离本簇上的边境点最近的路径点，将他分配过去，加上所有会被影响到的点



+ **9月6日**

![image-20220906205504344](C:\Users\18959\AppData\Roaming\Typora\typora-user-images\image-20220906205504344.png)

如图，绿色最左边的部分，其实可以只把这一个绿色箭头拿掉，当前还没有这种判断-》有了

2. 当前WRP算法非最优？（需要验证）

3. 新的h还是新的局部搜索算法

4. ![image-20220830103342701](C:\Users\18959\AppData\Roaming\Typora\typora-user-images\image-20220830103342701.png)

   **outlier的判定**和路径分配方法有问题，能看到不代表能到达，比如这里如果从(3,4）到(0，4)这条路径被夺走，(3,5)虽然看得到，却无法到达，应该是要分配给蓝色的

   ==解决方法==：剩下的点能到达的所有地方，而不是能看到的所有地方-》用DFS即可-》**完成**

   还是不够，比如(8,5)到(3,5)这条绿色的路应该全部给红色，但是由于(8,6)(8,7)在绿色的路径上被经过了两次，即使砍掉绿色在(8,5)之后的所有路径全部给红色，剩下的绿色路径仍然会经过(8,6)(8,7)，这样就冲突了，不能既是红色又是绿色

   ==解决方法==：被影响到的路径，如果有其他交接点，那么就连接到其他交接点上面去-》**完成**
   
   
   
   
   

+ **9月13日**

  遗传算法：

  目标函数：最小化路径

  适应性函数：目标函数的倒数

  制约条件-》路径的连续性

  mutation: inversion, insertion, interchange

​		100个个体，迭代10次，crossover=0.4,mutation=0.05



​		路径问题：对每个节点都采用优先级编码

​		如果到达已访问的点，那么进行惩罚（额外的代价）

+ **9月18日**

  改良结束条件，修复平衡聚类失败问题
  
  使用地图1_lak101是，多agent情况下运行十分的慢-》能判断的边界条件过多
  
  lak101d: 地图size大，但是中心区域无障碍物
  
  maze_21d: 地图size稍大，且障碍物数量略多
  
  11d:地图size小且障碍物多
  
  地图size大中心区域少量障碍物
  
+ **9月20日**

  地图size大中心区域少量障碍物的情况无法对应

  ![image-20220920104946962](C:\Users\18959\AppData\Roaming\Typora\typora-user-images\image-20220920104946962.png)

![image-20220920114439256](C:\Users\18959\AppData\Roaming\Typora\typora-user-images\image-20220920114439256.png)

该地图根据起点不同消耗时间差距较大，WRPsolver没有问题，之前地图测试设置有问题，起点没有成功重置

涉及到的路径上最近点是否相同

+ **deepcopy花了很多时间: **尽量利用其他方式来代替deepcopy，如copy来代替deepcopy

+ **h函数需要进一步优化, 不能导致极端情况出现，如有些agent为0，这是不能接受的：**用var来代替mean，分类结果会更加合理，速度是否会更快还需要其他地图来验证

+ 重复情况一

  ![image-20220927092446851](C:\Users\18959\AppData\Roaming\Typora\typora-user-images\image-20220927092446851.png)

  想将画红圈的蓝色部分分配给红色。该cell上和右都是与红色邻接，而最近的cell和需要被分配给红色的cell是完全相同的，造成了重复计算

  **解决办法：**

  1. 从路径上来考虑，对每个路径找最近的边界点，会损失一部分判断-》不采用

  2. 对于开放式地图的算法-》使用agg_h启发式函数会使速度大幅度提升，还可以选择改变权重来加速

     （MST，TSP启发式对开放式地图就是很慢）-》完成

​			

+ **10月6日**

现在可视化函数和获取种类函数可以应用于多class（分配的地方暂时用的是随机选择一种）

1. 在分配cell时，如果这次的分配导致极不平衡的结果，可以选择剪枝

   不同地图效率和性能的取舍取决于超参数epsilon的选取

   $\frac{postA*value}{preA*value}\ge epsilon\rightarrow prune$

   如果结果很慢，可以取epsilon=1, 从效率观点考虑1.5差不多 -》自适应

2. 重复计算问题的解决 ->解决

   （如何判定重复，重复到了什么程度）



+ **10月16日**

1. v2版本，当前配置聚类失败，找原因-》因为聚类中心是采用取整的方式，有可能到最后不会收敛，而是左右反复，这种情况下，达到最大迭代次数后任选其中一个中心即可

2. 整合缓存部分代码（创造新函数），看看效率变化-》完成

3. 聚类时一个cell可以属于多个类

   ![image-20221018123156313](C:\Users\18959\AppData\Roaming\Typora\typora-user-images\image-20221018123156313.png)

   cell(3,2): red,blue -> (3,2): blue  , path of S0 will change from 2->0

   cell(2,3): red,blue-> (2,3): red , path of S1 will change from 2->0

   paths of  two agents: 2,2->0,2->0,0      max(path)+w*var(path)+mean(path) 

   judge process:

   considering cell(3,2) 14  and cell(2,2) 10

   assign cell(3,2) to the agent which cell(2,2) belongs to

   cell(3,2): red, blue cell(2,2): red, blue

   4 possibilities, 2 of  them are need to be considered

   when cell(3,2) is red, cell(2,2) is blue, do assign operation

   

   

   以距离轮次从小到大的处理每个簇的reachable，如距离1时，cluter0有2个reachable,全部归给cluster0,cluster1有3个，全部归给cluster1，如果已经属于cluster0也无所谓，则比较距离，如果距离相同，满足multi-class

   加入距离相同的做相同分类，(2,3)这个点同样会是红蓝，使得距离变长

   这部分距离边长很多余的话，在第二阶段尝试按照正常步骤处理颜色（处理共同区域），是否能达到最优解？

   

   

+ **10月24日**

  1. (path_len_cls_1-path_len_cls_2 < tolerance_size)  这个条件缺点：有的时候即使目前agent的路径相等，其实可以更短

     但整体来说是加快效率的好手段，对性能也有帮助

  2. h函数改动，加平均值，方差加比例->完成

     f_v = np.max(paths)+w*np.var(paths)+np.mean(paths), w=cur_var_value/max_var_value

  3. epsilon 自适应
  
  4. bug:

![image-20221025094607636](C:\Users\18959\AppData\Roaming\Typora\typora-user-images\image-20221025094607636.png)

​				打算分配蓝色部分(6,8)及以后的cell，但起点也含在了里面(路径之后回到了起点往左边探索)，将起点一起分配掉的话，会导致算法失败-》解决方式：如果分配的cell中含有起点则排除，除了起点之外的所有cell都允许分配

+ **10月31日**

​		字典类型替换成list类型，还需要在相同环境下测试v4版本效果，V3已经更换，V4还没->完成

​		**epsilon 自适应**

​		![image-20221031100937638](C:\Users\18959\AppData\Roaming\Typora\typora-user-images\image-20221031100937638.png)

像这种情况，multi-class会有反作用，因为估计用的加速化手法会出问题，在进行分配时会被省略。（分配离cell最近的路径上的cell时，想象的是一部分路径会从红色给蓝色，然后估算Astar的变化，但实际上，这种情况下，分配cell只会导致红色减少，蓝色路径不会变长！）-》解决，在分配前先计算cls_2的cell和分配cell的交集，如果都是cls_2已有的cell显然path长度不变

分配方式也有多余的地方，比如考虑(0,2)这个点的将蓝色分配给红色，跟(0,1)(0,3)(1,2)都可以组对，但是结果是一样的-》解决，建立缓存，用过的就跳过

**还是性能不如V3，接着找原因**

+ 在multi-class环境下，有很多可能性是路径长度从(12,12)->(7,12)->(7,7),所以tolerance_size需要调整为0，path1只要不小于path2就考虑分配

+ **11月1日**

![image-20221101101753701](C:\Users\18959\AppData\Roaming\Typora\typora-user-images\image-20221101101753701.png)

其实单独cell的分配也有可能会影响路线的形成，比如图中，这个cell改成红色的话，最优路线会从19变成15



+ **11月7日**

  考虑V4版本的平衡聚类, 然后做大地图的实验测试

  重要的还是新的分配条件考虑，基于上面这个图的典型情况：

  + 首先，如果被分配的cell不在路径上，那么分配后，原agent的新path<=老path

  考虑分配cellA-》与这个cell关联的agent路径上的cellB，cellA的分配是否会让cellB的存在无意义

  + 如果被分配的cell在路径上，分配后如果区域断开和不断开要分情况讨论

  ​		不断开：原先的路径不能走了，需要换一条路，可能短可能长？

  ​						对于不断开的判断标准需要改良-》

  ​						对于后续的路径来说，只有他们其中有一个cell，能在empty_cells中找到一个新的连接点（排除他们自身），就仍然还   						是联通的。

  ​		对于新方法，有两个情况需要考虑，即1和0

  ```python
  new_path_cls_1 = path_cls_1[:cell_idx_in_path[0]]
  new_path_cls_1 = path_cls_1[:cell_idx_in_path[0]] + \
                                       path_cls_1[cell_idx_in_path[1] + 1:]
  for c in new_path_cls_1:
  	if self.APSP_d[succ, c] <= 1:  # find successor
  ```

  ​		区域断开：后续路径需要一起分配，好说

  **原先的分配方式好像可以？将圈起来的点和右边路径上的点一起分配就可以了！因为在这里单个cell的分配实际上和两个cell的分配结果是一样的，如下图-》完成**

  ![image-20221107203445972](C:\Users\18959\AppData\Roaming\Typora\typora-user-images\image-20221107203445972.png)

  

+ **11月8号**

[25, 13, 15, 33] 0_lak101d这个情况的时候运行特别慢，需要找找原因-》展开了10599个node

![image-20221108103405536](C:\Users\18959\AppData\Roaming\Typora\typora-user-images\image-20221108103405536.png)

为什么不是S0去紫色而是更远的S3去紫色？-》按顺序分配时，S0已经被红色选择了，所以最后只剩下S3去紫色，造成了不合理

这是一个组合优化问题：对于每个起点来说，都有4个距离

而我们需要选择综合距离最短的。

+ **11月14号**

python版本更新完成

然后考虑一下是否需要测试100次->应该还是要

字典的get方法-》改不了，主要是copy里面用的

copy-》改不了

深度优先探索-》优化完成

+ **11月21号**

  + [numba](https://numba.pydata.org/numba-doc/latest/user/jit.html)：没用，60s变成了70s

  + https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ranksums.html

  + 然后开始得找减少节点展开数的方法-》未解决

    ```
    start pos: [(9, 20), (15, 14), (11, 10), (26, 10)] 卡了很久
    ```


  + 继续提升性能，还有优化空间--->已完成

    ==也是参数选择导致的非最优路线出现，导致没有找到真的最优路线==

    ```
    start = [(2, 1), (14, 11), (11, 0), (12, 4), (16, 0)]
    "2_maze_21d.txt"
    node展开数：637
    ```

    ![image-20221121104317995](C:\Users\18959\AppData\Roaming\Typora\typora-user-images\image-20221121104317995.png)

    为什么这里没有被优化的原因：

    ==明明不需要改变路径长度，但是改变了，而且是朝着坏的方向==

    [69, 39, 29, 36, 50]

    ![image-20221121205148518](C:\Users\18959\AppData\Roaming\Typora\typora-user-images\image-20221121205148518.png)

  + IW和WR的参数选择问题，都为False的时候才是最优解：写一个综合的执行文件，能比较各个候补->完成

  + agg_h的结果有时会弱于MST

    agg_h结果

    ![image-20221121171113792](C:\Users\18959\AppData\Roaming\Typora\typora-user-images\image-20221121171113792.png)

    MST结果

    ![image-20221121171145168](C:\Users\18959\AppData\Roaming\Typora\typora-user-images\image-20221121171145168.png)

    

+ 如何减少node的展开个数？

用語：

最適解(x)ー＞best found by algorithm, 最良

给同等时间，看看解的质量差异-》no

给同等目标，看谁更快达到目标-》no

给一个目标，在限定时间内，谁成功了多少次来比较-》no

1.展开数减少-》需要一些方法

2.停止条件

+ **12月29号**

is_next_2来说，如果被分配的路线包含起点，那么深度优先探索根本就无法进行，从起点开始就被分配走了-》如果分配中包含起点，那么就跳过



地图来源：https://movingai.com/benchmarks/legacy/dao/index.html

实验部分的对比：首先是不同启发式函数之间的结果对比，不同地图之间（障碍物多少，体积变化）

+ sum和max用的同一个基准，或者就干脆先不要minsum基准-》只用minmax，记得找个地方说明

+ 最开始的初期结果？



